/********************************************* JEST *****************************************/

// Expected - то, что ожидали получить
// Received - то, что получили по факту
// асинхронные функции проверяем с помощью async перед коллбэком (например: test('test', async () => {)

// проверяем, что функция возвращает примитивное значение и равно этому значению
// expect(...).toBe(true)

// проверяем, что функция возвращает объектное значение и равно этому значению
// expect(...).toEqual(['1', '2', '3'])

// проверяем, что функция возвращает объектное значение и НЕ равно этому значению (приставка not)
// expect(...).not.toEqual([1, 2, 3, 4])

// проверяем, что результат меньше, чем 2
// expect(...).toBeLessThan(true)

// проверяем, что результат больше, чем 2
// expect(...).toBeGreaterThan(true)

// проверяем, что результат является или не является undefined
// expect(...).toBeUndefined() || expect(...).not.toBeUndefined()

// запускается перед каждым тестом
// beforeEach(() => {
// });

// запускается один раз перед всеми тестами
// beforeAll(() => {
// });

// запускается после каждого теста (например очищение моков (jest.clearAllMocks()), т.к. все моки накапливаются)
// afterEach(() => {
// });

// запускается один раз после всех тестов
// afterAll(() => {
// });

// проверяем, что функция будет вызвана 1 раз
// expect(...).toBeCalledTimes(1);

// эта методика предоставляет возможность мокать какие-либо методы в функциях (т.е. прямым текстом сказать, что данный метод сейчас возвращает такое-то значение). Моканье используется для того, чтоб протестировать конкретный метод функции, а не всю функцию целиком. Например, у нас есть функция с несколькими ифами. Мы вызываем функцию с определенным значением и мокаем вызов именно с этим значением. если нам нужно, чтоб сработал другой иф, то мы мокаем уже другой вызов. Таким же способом можно мокать конкретные методы объектов, чтоб не трогать весь объект. Например, мы создали переменную, в которую поместили вызов нашего метода. После этого мы вызываем нашу функцию с аргументом два.потом замоконную функцию мы передаем в expect и с помощью toBeCalledTimes проверем, сколько раз сработает функция (мы указали, что функция сработает один раз).
// const spyMathPow = jest.spyOn(Math, 'pow');
// squarePow(2);
// expect(spyMathPow).toBeCalledTimes(1);

// позволяет мокать библиотеки и функции
// jest.mock()

// позволяет сохранить результаты выполнения теста в папке __snapshots__, после чего мы сможем сравнить результаты выполнения прошлого теста и нынешнего (если они будут отличаться и падать)
// expect(data).toMatchSnapshot();

/********************************************* React Testing Library *****************************************/

// возвращает разметку JSX
// screen.debug();

// методы, начинающиеся на:
// findBy - находит один элемент, обернутый в промис.Т.е. для работы с асинхронным кодом;
// findAll - находит массив элементов;
// getBy - находит один элемент, при этом если не находит, то бросается ошибка и тест падает;
// getAll - находит массив элементов;
// queryBy - находит один элемент, при этом если не находит, то возвращает null. Можно проверить на null, тем самым избежав проброса ошибки. В основном используется, чтоб доказать отсутствие компонента на странице;
// queryAll - находит массив элементов;

// находим элемент по указанному тексту на странице (в данном случае игнорируем регистр с помощью регулярки)
// screen.[find|get|query]ByText(/hello world/i)

// находим элемент по роли (можно переопределить с JSX с помощью атрибута role="button")
// screen.[find|get|query]ByRole('button')

// находим элемент по плейсхолдеру
// screen.[find|get|query]ByPlaceholderText(/input value.../i);

// находим элемент по атрибуту data-testid (в JSX: data-testid="toggle-btn")
// screen.[find|get|query]ByTestId("toggle-btn")

// проверяем, что элемент появился на странице
// expect(element).toBeInTheDocument()

// проверяем, что элемент отсутствует на странице
// expect(element).toBeNull();

// проверяем, что у компонента есть вот такие стили
// expect(element).toHaveStyle({color: 'red'});

// проверяем, что у нас отрисовался заголовок с текстом
// expect(element).toHaveTextContent("test");

// объект события, с помощью которого мы эмулируем какое-то событие (в данном случае onClick и input)
// fireEvent.click(element);
// fireEvent.input(input, {target: {value: '123123'}});

// вызывать события, которые эмулируют действия пользователя, а не конкретные события JS (import userEvent from "@testing-library/user-event")
// userEvent.type(input, "123123")

// для того, чтобы тестировать компонент в связке с RRD, помещаем тестируемый компонент в спец обертку (иначе работать не будет). Здесь же можно передать в initialEntries массив рандомных путей, по которым будет рендериться этот компонент
// <MemoryRouter initialEntries={['/asdasd']}>
//   <App />
// </MemoryRouter>;

/********************************************* WebDriverIO *****************************************/
// если такая ошибка (ERROR @wdio/runner: Error: Failed to create session. [0-0] session not created: This version of ChromeDriver only supports Chrome version 108 [0-0] Current browser version is 115.0.5790.170 with binary path /usr/bin/google-chrome), то обновляем chromedriver до последней версии
